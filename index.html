<!doctype html>
<html lang="sl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Timer (UTC+2) — 32s red / 25s green / 3s red</title>
  <style>
    :root{font-family: Inter, system-ui, -apple-system, Roboto, "Helvetica Neue", Arial;}
    html,body{height:100%;margin:0}
    body{display:flex;align-items:center;justify-content:center;background:#000;color:#fff}
    .wrap{width:100vw;height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center;padding:20px;box-sizing:border-box}
    .ring{width:84vmin;max-width:680px;max-height:680px;aspect-ratio:1/1;border-radius:50%;display:flex;align-items:center;justify-content:center;box-shadow:0 10px 30px rgba(0,0,0,.35)}
    .label{font-size:5.5vmin;font-weight:600}
    .sec{font-size:12vmin;font-weight:800;letter-spacing:-0.02em}
    .sub{margin-top:8px;font-size:3.6vmin;opacity:.9}
    .controls{position:fixed;left:14px;bottom:14px;display:flex;gap:8px}
    button{background:rgba(255,255,255,.08);border:0;padding:10px 12px;border-radius:10px;color:#fff;font-weight:600}
    .small{font-size:2.8vmin;opacity:.95}
    @media (orientation:landscape){ .sec{font-size:9vmin} }
  </style>
</head>
<body>
  <div class="wrap">
    <div id="ring" class="ring" role="img" aria-live="polite" aria-label="Timer">
      <div>
        <div id="label" class="label">—</div>
        <div id="secs" class="sec">00.0</div>
        <div id="phase" class="sub">UTC+2 čas</div>
      </div>
    </div>
    <div style="height:12px"></div>
    <div class="small">Prvih 32s: rdeče • naslednjih 25s: zeleno • zadnje 3s: rdeče<br>Časovni pas: UTC+2 (fiksno) • zamik: +2s</div>
  </div>

  <div class="controls">
    <button id="fs">Fullscreen</button>
    <button id="wake">Wake lock</button>
  </div>

  <script>
    // Settings for the phases (seconds within each minute)
    const PHASES = [
      {name: 'RED', color: '#cc1f1f', duration: 32},
      {name: 'GREEN', color: '#13a44d', duration: 25},
      {name: 'RED', color: '#cc1f1f', duration: 3}
    ];

    // ✅ Timer offset relative to UTC+2 (in seconds)
    // This keeps the cycle 60s long, but shifts it by 2 seconds.
    const OFFSET_SECONDS = 2;

    // compute cumulative boundaries for quick checks
    const boundaries = [];
    let acc = 0;
    for (const p of PHASES) { acc += p.duration; boundaries.push(acc); }
    // boundaries should equal 60

    const labelEl = document.getElementById('label');
    const secsEl = document.getElementById('secs');
    const phaseEl = document.getElementById('phase');
    const ringEl = document.getElementById('ring');

    // Wake lock handling (optional, user can enable)
    let wakeLock = null;
    async function tryWakeLock() {
      try {
        if ('wakeLock' in navigator) {
          wakeLock = await navigator.wakeLock.request('screen');
          wakeLock.addEventListener('release', () => {
            document.getElementById('wake').textContent = 'Wake lock';
          });
          document.getElementById('wake').textContent = 'Wake on';
        } else {
          alert('Wake Lock ni podprt v tem brskalniku.');
        }
      } catch (err) {
        console.warn('WakeLock error', err);
      }
    }
    document.getElementById('wake').addEventListener('click', tryWakeLock);

    // Fullscreen toggle
    document.getElementById('fs').addEventListener('click', async ()=>{
      try{
        if (!document.fullscreenElement) await document.documentElement.requestFullscreen();
        else await document.exitFullscreen();
      }catch(e){console.warn(e)}
    });

    // returns a Date object representing the current time shifted to UTC+2
    function nowUTCplus2() {
      const now = new Date();
      const utcMs = now.getTime() + now.getTimezoneOffset() * 60000;
      const tzMs = utcMs + 2 * 3600000; // UTC+2 in ms
      return new Date(tzMs);
    }

    function update() {
      const t = nowUTCplus2();

      // base seconds within minute
      let s = t.getSeconds() + t.getMilliseconds() / 1000; // 0.000 - 59.999

      // ✅ apply +2s offset to the timer (cycle stays 60s)
      // Meaning: timer "minute" starts at xx:xx:02 (UTC+2).
      s = (s - OFFSET_SECONDS + 60) % 60;

      // determine phase index
      let phaseIndex = 0;
      for (let i=0;i<boundaries.length;i++){
        if (s < boundaries[i]){ phaseIndex = i; break; }
      }
      const phase = PHASES[phaseIndex];

      // compute time left in this phase
      const phaseEnd = boundaries[phaseIndex];
      const left = Math.max(0, phaseEnd - s);

      // update UI
      ringEl.style.background = phase.color;
      labelEl.textContent = phase.name === 'RED' ? 'RDEČE' : 'ZELENO';

      // show seconds with one decimal place
      secsEl.textContent = left.toFixed(1).padStart(4,'0');
      phaseEl.textContent = `Faza ${phaseIndex+1} · ${phase.duration}s (UTC+2) · zamik +${OFFSET_SECONDS}s`;

      // adjust text colour for contrast
      document.body.style.color = '#fff';
    }

    // Start updates. Use requestAnimationFrame loop tuned to ~100ms updates for balance.
    let last = 0;
    function loop(ts){
      if (!last || ts - last >= 100) { update(); last = ts; }
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    // On page visibility change, try to re-establish wake lock if held
    document.addEventListener('visibilitychange', async ()=>{
      if (wakeLock !== null && document.visibilityState === 'visible') {
        try {
          wakeLock = await navigator.wakeLock.request('screen');
        } catch(e){ console.warn('wakeLock re-request failed', e); }
      }
    });

    // friendly hint: tap anywhere to toggle fullscreen (mobile)
    ringEl.addEventListener('click', async ()=>{
      try{
        if (!document.fullscreenElement) await document.documentElement.requestFullscreen();
        else await document.exitFullscreen();
      }catch(e){}
    });

    // initial update
    update();
  </script>
</body>
</html>
